<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Sumit Gupta's Blog]]></title>
  <link href="http://timusg.github.io/atom.xml" rel="self"/>
  <link href="http://timusg.github.io/"/>
  <updated>2013-12-09T23:15:11+05:30</updated>
  <id>http://timusg.github.io/</id>
  <author>
    <name><![CDATA[timusg]]></name>
    <email><![CDATA[timusga@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[code test and automate infrastructure]]></title>
    <link href="http://timusg.github.io/blog/2013/11/07/code-test-and-automate-infrastructure/"/>
    <updated>2013-11-07T16:36:00+05:30</updated>
    <id>http://timusg.github.io/blog/2013/11/07/code-test-and-automate-infrastructure</id>
    <content type="html"><![CDATA[<p><span class='pullquote-right' data-pullquote='Infrastructure as code mantra'></p>

<p>Managing infrastructure by hand or shell scripts is pain specially if your application architecture consists of multiple services.
For scaling such application adoption of Infrastructure as code mantra is a must have.
There are many ways and frameworks to japa this mantra and Chef, puppet ansible are few of many tools in configuration management segment which provides DSL to implement automated configuration , software installation , deployment etc &#8230;</p>

<p>This area overlap between dev and ops domain and because of different skillset and practices of these domains, tools/patterns are still evolving to use the best of both domains,
slowly but it is picking up pace with recent increase in devops skills as more and more experts from both domains has started contributing in it.
</span></p>

<p>This post is about our adoption of this mantra with chef and applying current best practices for code, test and automate infrastructure.</p>

<!--more-->


<h2>Part One - The Code</h2>

<p>Code should be extensible, maintainable, reusable and in short modular
but keeping all chef code in single repository makes it bit difficult.</p>

<h3>Problems:</h3>

<ul>
<li>Cookbooks in one big repository are difficult to develop and test independently</li>
<li>Cookbooks in one repository are not modular and difficult to
distribute and reuse.</li>
<li>Code and data is in one place, but both changes with different pace.</li>
</ul>


<h3>Solution:</h3>

<p>To solve modularity issue, we use <a href="http://berkshelf.com/">berkshelf</a>.
It not only help in distributing and reusing cookbooks in a easy way, but also provides a foundation to apply good software principals, most of ideas in this post are from berkshelf itself.</p>

<p><em>We take care of following points while writing chef code.</em></p>

<ul>
<li>Use community cookbooks and if required write wrappers for extension.</li>
<li>No roles, use aggregated recipes
instead, roles provides global variables and also not versioned.</li>
<li>Use convention over configuration with using search and sane defaults.</li>
<li>Create application cookbook with independent git repo for every
application service.</li>
</ul>


<p>Following are the cookbook types and patterns, which I frequently encounter while writing chef code.</p>

<h2>Cookbook types and Patterns</h2>

<h3><a name="wrappercookbook"></a> Wrapper Recipe</h3>

<p>Wrapper recipe is like decorator pattern and is basic unit for extending <a href="#communitycookbook">community cookbooks</a>.</p>

<figure class='code'><figcaption><span>db.rb</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">include_recipe</span> <span class="s2">&quot;postgresql::server&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">foo</span> <span class="s2">&quot;extra configuration for db&quot;</span> <span class="k">do</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Wrapper recipe provides a way to encapsulate third party logic with your
logic in one recipe.</p>

<h3>Aggregated Recipe</h3>

<p>These are equivalent to aggregation pattern and only includes other recipes.</p>

<figure class='code'><figcaption><span>application cookbook: default.rb</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">include_recipe</span> <span class="s1">&#39;app&#39;</span>
</span><span class='line'><span class="n">include_recipe</span> <span class="s1">&#39;db&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>These are ideal candidate to replace roles,
For example default recipes can aggregate app and db recipes, and provide a role to quickly set up a dev test machine.</p>

<h3>Private Recipe</h3>

<p>Private recipe is like the abstract class and not exposed to public (outside of
 cookbook), can be used for code separation or reuse inside cookbook, it is convention to prefix its name with _ (underscore)</p>

<figure class='code'><figcaption><span>private recipe example</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>.
</span><span class='line'>-- recipes
</span><span class='line'>    |-- _common.rb
</span><span class='line'>    |-- app.rb
</span><span class='line'>    <span class="sb">`</span>-- cache.rb
</span></code></pre></td></tr></table></div></figure>


<h3><a name="communitycookbook"></a> Community Cookbooks</h3>

<p>These are the open source cookbooks and maintained by community. These are Available in opscode or similar site for download.
Instead of reinventing the wheel prefer to use community cookbooks.</p>

<h3><a name="applictioncookbook"></a> Application Cookbook</h3>

<p>Application cookbook is the container of the configuration code for the application, I prefer to create one cookbook for
each rest service and different recipes in it for its various infrastructural layers for example recipes for each layer like db, app, cache, proxy, elb so on</p>

<figure class='code'><figcaption><span>application cookbook dir structure</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>.
</span><span class='line'>|-- Berksfile
</span><span class='line'>|-- Vagrantfile
</span><span class='line'>|-- attributes
</span><span class='line'>|   |-- app.rb
</span><span class='line'>|   <span class="sb">`</span>-- db.rb
</span><span class='line'>|-- metadata.rb
</span><span class='line'><span class="sb">`</span>-- recipes
</span><span class='line'>    |-- app.rb
</span><span class='line'>    |-- db.rb
</span><span class='line'>    <span class="sb">`</span>-- cache.rb
</span></code></pre></td></tr></table></div></figure>


<p>It provides a name space for application and its layers, for example application foo&#8217;s
database is searchable with foo::db name so it replace role for
tag and search requirements.</p>

<p>Although multiple thin services based architecture often tempt to use one cookbook using some sort of tagging, but this approach often leads to conditional code in the end, So consider to use <a href="#librarycookbook"> library cookbook </a> for code reuse in application cookbooks.</p>

<h3><a name="librarycookbook"></a> Library Cookbook</h3>

<p>Library cookbook is like the brain and heart of application&#8217;s configuration codebase, it is container of all the common code required in application cookbooks.
It is like abstarct class at cookbook level and thus contains no recipe and only provides abstraction over common code with lwrps and definitions.</p>

<p>Common code includes code for set up app servers (puma/nginx combo, torquebox), application rpm/omnibus installers and so on and depends on application stack.</p>

<p>It can be combined with the <a href="#basecookbook">base cookbook</a> which
provides recipes for basic node configuration.</p>

<h3><a name="basecookbook"></a> Base Cookbook</h3>

<p>It provides recipes for basic system configuration.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.
</span><span class='line'>|-- Berksfile
</span><span class='line'>|-- Vagrantfile
</span><span class='line'>|-- attributes
</span><span class='line'>|   |-- stagging.rb
</span><span class='line'>|   `-- production.rb
</span><span class='line'>|-- metadata.rb
</span><span class='line'>`-- recipes
</span><span class='line'>    |-- _common.rb
</span><span class='line'>    |-- stagging.rb
</span><span class='line'>    `-- production.rb</span></code></pre></td></tr></table></div></figure>


<p>I prefer to have separate recipes for different environments.</p>

<p>It replace the base role and install basic packages like Vim, tmux/screen, yum repos, environment specific tools like debug, tracing tools, monitoring agents etc. The benefit over role is that you can version it and also using different recipes for different environments provides more flexibility.</p>

<p>It can be combined with the <a href="#librarycookbook">Library cookbook</a>.</p>

<h3><a name="rolecookbook"></a> Role Cookbook</h3>

<p>This cookbook is replacement for the roles and can be used in place of base
cookbook if more fine grained control required for configuring roles.</p>

<p>But since we use application cookbook with roles like recipe names, this
cookbook is not really required.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.
</span><span class='line'>|-- Berksfile
</span><span class='line'>|-- Vagrantfile
</span><span class='line'>|-- attributes
</span><span class='line'>|   |-- web-server.rb
</span><span class='line'>|   `-- db.rb
</span><span class='line'>|-- metadata.rb
</span><span class='line'>`-- recipes
</span><span class='line'>    |-- web-server.rb
</span><span class='line'>    `-- db.rb</span></code></pre></td></tr></table></div></figure>


<h3>Infrastructure Essential Cookbook</h3>

<p>Any infrastructure contains two type of components</p>

<ul>
<li>Application and its dependencies like db, cache</li>
<li>Other essential components which crosscut entire infrastructure like chef server, etcd, bind, vpn, monitoring servers and CI server</li>
</ul>


<p>As Application cookbook take care of application related stuff, for configuring second I prefer to create another cookbook and I call it infra essential cookbook and it contains recipes and scripts for all remaining essential components, It also utilize wrapper recipe pattern with community cookbooks.</p>

<p>This cookbook provides two benefits</p>

<ol>
<li>one place for all scripts and recipes for all essential infrastructure
components.</li>
<li>A namespace, which is useful for searching and setting fqdn etc in
application cookbooks.</li>
</ol>


<p><em>Library, base and infrastructure cookbooks can be combined in one
cookbook like mixed
patterns or stay in their own cookbooks, but it all depends on codebase size
and testing needs</em></p>

<h2>Follow Up</h2>

<p>This post mainly covered the modularity and pattern aspects in chef
code base, follow-up posts of this series will cover code data separation, testing and auto deployment/provisioning strategies in chef managed infra.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing chef cookbook with docker and test kitchen]]></title>
    <link href="http://timusg.github.io/blog/2013/10/15/testing-cookbook-with-docker-and-test-kitchen/"/>
    <updated>2013-10-15T17:44:00+05:30</updated>
    <id>http://timusg.github.io/blog/2013/10/15/testing-cookbook-with-docker-and-test-kitchen</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/opscode/test-kitchen">Test Kitchen</a> is a framework for isolated integration testing of chef
recipes</p>

<p>For testing a recipe it spawn a vm, execute tests and then destroys it.
For local cookbook development and manual testing of changes
<a href="http://www.vagrantup.com/">vagarnt</a> is definitely the best choice,
but for developing cookbook with automated tests suits faster test feedback is really important, since VM based approach is very
slow and it is worth to try containers for cookbook testing.</p>

<!--more-->


<h2>Optimisation with containers</h2>

<p>Containers like openvz and lxc are faster to launch and are very lightweight as compared to virtual box and other VM based backends.</p>

<p>As compared to openvz, lxc is available on the mainstream linux kernel but managing lxc container with scripts
is not an easy task, there are two lxc baced framework available, <a href="https://github.com/fgrehm/vagrant-lxc">vagrant lxc</a>(vagrant lxc provider) and <a href="https://www.docker.io/">docker</a> (package and run application as container) which provides
good abstraction layer over lxc.</p>

<p>Test kitchen has a architecture for pluggable virtualization backend and it support vagrant, ec2 and recently
with <a href="https://github.com/portertech/kitchen-docker">kitchen-docker</a> plugin, docker can also used as driver.</p>

<p>I am using following setup to use test kitchen with docker.</p>

<h2>Setup</h2>

<h3>Install docker</h3>

<p><a href="https://www.docker.io/gettingstarted/">Install</a> it for supported
platform or
Install it with community cookbook with chef and berkself</p>

<figure class='code'><figcaption><span>Berksfile to install docker</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">site</span> <span class="ss">:opscode</span>
</span><span class='line'><span class="n">metadata</span>
</span><span class='line'><span class="n">group</span> <span class="ss">:integration</span> <span class="k">do</span>
</span><span class='line'><span class="n">cookbook</span> <span class="s1">&#39;docker&#39;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Install test-kitchen and docker driver</h3>

<p>Can be installed with bundler by using following Gemfile file</p>

<figure class='code'><figcaption><span>Gemfile</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">source</span> <span class="s1">&#39;https://rubygems.org&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">gem</span> <span class="s1">&#39;berkshelf&#39;</span><span class="p">,</span> <span class="s1">&#39;~&gt; 2.0&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">group</span> <span class="ss">:integration</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">gem</span> <span class="s1">&#39;test-kitchen&#39;</span><span class="p">,</span> <span class="s1">&#39;~&gt; 1.0.0.beta&#39;</span>
</span><span class='line'>  <span class="n">gem</span> <span class="s1">&#39;kitchen-docker&#39;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Sample Cookbook</h3>

<p>Download <a href="https://github.com/opscode-cookbooks/ntp.git">ntp</a> cookbook for testing, beacuse it also serve as a testing documentation reference</p>

<h2>Execute Tests</h2>

<p>Change .kitchen.yml file of ntp cookbook to use kitchen docker plugin</p>

<figure class='code'><figcaption><span>example .kitchen.yml</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="nn">---</span>
</span><span class='line'><span class="l-Scalar-Plain">driver_plugin</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">docker</span>
</span><span class='line'><span class="l-Scalar-Plain">driver_config</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">require_chef_omnibus</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">platforms</span><span class="p-Indicator">:</span>
</span><span class='line'><span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">centos</span>
</span><span class='line'>  <span class="l-Scalar-Plain">driver_config</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="s">&quot;centos&quot;</span>
</span><span class='line'>    <span class="l-Scalar-Plain">platform</span><span class="p-Indicator">:</span> <span class="s">&quot;rhel&quot;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">run_list</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">recipe[yum]</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">suites</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">default</span>
</span><span class='line'>    <span class="l-Scalar-Plain">run_list</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">recipe[ntp::default]</span>
</span><span class='line'>    <span class="l-Scalar-Plain">attributes</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">ntp</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="l-Scalar-Plain">sync_clock</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
</span><span class='line'>        <span class="l-Scalar-Plain">sync_hw_clock</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">undo</span>
</span><span class='line'>    <span class="l-Scalar-Plain">run_list</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">recipe[ntp::undo]</span>
</span></code></pre></td></tr></table></div></figure>


<p>And run kitchen to execute tests in docker container</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">bundle</span> <span class="nb">exec</span> <span class="n">kitchen</span> <span class="nb">test</span>
</span></code></pre></td></tr></table></div></figure>


<h2>More optimisations</h2>

<p>Test Kitchen downloads chef omnibus package every time while spawning
a container, this step takes both time and bandwidth, this can be turned
off by setting require_chef_omnibus flag to false, following are other options to optimize this</p>

<ul>
<li>use local repository for chef omnibus and override chef_omnibus_url flag</li>
<li>use lightweight gem like chef zero</li>
<li>utilize docker cache with  provision_command command</li>
<li>build new image with installed chef for testing</li>
</ul>


<p>New image can be easily created by using following
commands</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>cat <span class="s">&lt;&lt; &#39;EOF&#39; &gt; Dockerfile</span>
</span><span class='line'><span class="s">FROM centos</span>
</span><span class='line'><span class="s">RUN curl -L https://www.opscode.com/chef/install.sh | sudo bash</span>
</span><span class='line'>
</span><span class='line'><span class="s">RUN #install additopnal packages</span>
</span><span class='line'>
</span><span class='line'><span class="s">EOF</span>
</span><span class='line'>docker build -t  image_name .
</span></code></pre></td></tr></table></div></figure>


<p>Set image key to image_name in .kitchen.yml
file and execute tests more faster.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hoppr Platform in Last 10 Months]]></title>
    <link href="http://timusg.github.io/blog/2013/04/27/hoppr-platform-in-last-10-months/"/>
    <updated>2013-04-27T20:45:00+05:30</updated>
    <id>http://timusg.github.io/blog/2013/04/27/hoppr-platform-in-last-10-months</id>
    <content type="html"><![CDATA[<h2>Hoppr Platform Now</h2>

<p>with 7.6 m users hoppr platform is now handling around 600k checkins and 3m+ events per day.</p>

<p>underline is a heavily distributed architecture spread across three data centers and aws vpc.
it support zero downtime deployment and minimalistic service availability even in case of wan link failure.</p>

<!--more-->


<h2>Tech Stack :</h2>

<ul>
<li>polyglot , 80% code base in ruby and 20 % in java , node and php</li>
<li>mongo</li>
<li>redis</li>
<li>mysql (percona)</li>
<li>elasticsearch</li>
<li>torquebox and hornetq</li>
<li>chef</li>
<li>nagious</li>
<li>apache and haproxy</li>
<li>centos</li>
<li>openvz</li>
</ul>


<h2>A big rewrite</h2>

<p>it all start with a big rewrite of the the existing platform , which
was a big fat jsp code base, repeated for 6 telcos , code was not unit tested and
not even close to mvc 1.</p>

<p>initial version of new platform is developed in 2 months with a core domain
layer and application layer for vendor and access medium specific code.
the idea was to develop a core domain layer serve as api and other as application layer for device/vendor specific code, now we have around 20 similar micro services (some RESTish and some json over http),
each service is highly cohesive to device , vendor or a context.
apart from acting as anti corruption layers these micro services can also scale out independently.</p>

<h2>Vertical to Horizontal</h2>

<p>for first few months we tried to scale up with torquebox in big box with jvm optimized for huge pages, but
for zero downtime deployment and HA, we moved to scale out with openvz
containers with apache/ mod_cluster(http) and haproxy(jms) as load balancers.</p>

<p>we automated box setup to one click deployment using chef, and now we
have around 50 nodes handling all load.</p>

<h2>More About Architecture</h2>

<p>ussd checkin in our system requires response in less then
200ms , so system is modeled in events and base event checkin is
processed in less then 50ms, a checkin further emits another max 5 events for
various post processing actions , each event is processed by one or all sites.</p>

<p>site is cluster of backend services with own db and cache deployed in different datacenter,
and can independently process basic checkin and generally optimized for specific access
mediums.</p>

<p>sites are connected by a vpn tunnel over lease line.
site can play one or multiple role and we control it by giving it
capability and capability is controlled by chef.</p>

<p><strong>distributed architecture over wan is not a big deal ,but problems starts if it is not a shared nothing</strong> , and multiplies with type and intensity of sharing.</p>

<p>for some internal requirements we have to go with wan distribution and
hence to sync lots of data for mobile portability and
points/skipper/leaderboard calculations.</p>

<p><em>multi site replication</em></p>

<p>for muti site replication we are using application layer sync and
created a custom sync framework with fan out and repeat on failure with exponential backoff features,
data consistency is achieved by design by contract on sync endpoints.</p>

<p>sync framework&#8217;s core is built with hornetq and netty connectors and it is working really great even with remote listeners.</p>

<p><em>replicating single source of truth</em></p>

<p>points and leadernoard is single source of truth and it is calculated by one site,
we also need to access this data syncronpusly and it is not possible
over vpn because of encryption and multiple connections overhead.</p>

<p>we tried various approaches to sync this, and finally followed cqrs type approach and now have different
request paths for read and writes. points are calculated in one site and synced to remote redis slave and read operation is always from redis slave.</p>

<p>redis sync is almost realtime and very fast even for master to slave
of slave over 2 hop vpn links separated datacenters.</p>

<p><em>tuning centos</em></p>

<p>system defaults not always works and cpu and memory sometimes are not
indicators of bottleneck. we tuned various kernel
parameters for network and connection related stuff.</p>

<p>more on this in following post</p>

<h2>Lesson Learned</h2>

<ul>
<li>dont trust your api users , they can stress your system in no time,  use timeouts and circuit breakers</li>
<li>redis sync is very fast and it sync in millis from master to slave of
slave even over 2 vpn link separated datacenters</li>
<li>visualize every things , logstaligia is great for apache logs visualization and quick indicator of load</li>
<li>adopt configuration management as soon as possible</li>
</ul>

]]></content>
  </entry>
  
</feed>
