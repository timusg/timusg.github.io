<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Sumit Gupta's Blog]]></title>
  <link href="http://timusg.github.io/atom.xml" rel="self"/>
  <link href="http://timusg.github.io/"/>
  <updated>2013-10-22T23:45:44+05:30</updated>
  <id>http://timusg.github.io/</id>
  <author>
    <name><![CDATA[Sumit Gupta]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Testing chef cookbook with docker and test kitchen]]></title>
    <link href="http://timusg.github.io/blog/2013/10/15/testing-cookbook-with-docker-and-test-kitchen/"/>
    <updated>2013-10-15T17:44:00+05:30</updated>
    <id>http://timusg.github.io/blog/2013/10/15/testing-cookbook-with-docker-and-test-kitchen</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/opscode/test-kitchen">Test Kitchen</a> is a framework for isolated integration testing of chef
recipes.</p>

<p>For testing a recipe it spawn a vm, execute tests and then destroys it.
For local cookbook development and manual testing of changes
<a href="http://www.vagrantup.com/">vagarnt</a> is definitely the first choice,
but for developing cookbook with automated tests suits this VM based approach is very
slow and as test kitchen destroys box with each run, testing feedback time become really important factor in development speed and is worthy candidate for
optimisation.</p>

<!--more-->


<h2>Optimisation</h2>

<p>Containers like openvz and lxc are faster to launch and are very lightweight as compared to virtual box and other VM based backends.</p>

<p>As compared to open vz, lxc is available on the mainstream linux kernel but managing lxc container with scripts
is not an easy task, there are two lxc baced framework available, <a href="https://github.com/fgrehm/vagrant-lxc">vagrant lxc</a>(vagrant lxc provider) and <a href="https://www.docker.io/">docker</a> (package and run application as container) which provides
good abstraction layer over lxc.</p>

<p>Test kitchen has a architecture for pluggable virualization backend and it support vagrant, ec2 and recently
with <a href="https://github.com/portertech/kitchen-docker">kitchen-docker</a> plugin, docker can also used as driver.</p>

<p>I am using following setup to use test kitchen with docker.</p>

<h2>Setup</h2>

<h3>Install docker</h3>

<p><a href="https://www.docker.io/gettingstarted/">Install</a> it for supported
platform or
Install it with community cookbook with chef and berkself</p>

<figure class='code'><figcaption><span>Berksfile for install docker</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">site</span> <span class="ss">:opscode</span>
</span><span class='line'><span class="n">metadata</span>
</span><span class='line'><span class="n">group</span> <span class="ss">:integration</span> <span class="k">do</span>
</span><span class='line'><span class="n">cookbook</span> <span class="s1">&#39;docker&#39;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Install test-kitchen and docker driver</h3>

<p>Can be installed with bundler by using following Gemfile file</p>

<figure class='code'><figcaption><span>Gemfile</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">source</span> <span class="s1">&#39;https://rubygems.org&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">gem</span> <span class="s1">&#39;berkshelf&#39;</span><span class="p">,</span> <span class="s1">&#39;~&gt; 2.0&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">group</span> <span class="ss">:integration</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">gem</span> <span class="s1">&#39;test-kitchen&#39;</span><span class="p">,</span> <span class="s1">&#39;~&gt; 1.0.0.beta&#39;</span>
</span><span class='line'>  <span class="n">gem</span> <span class="s1">&#39;kitchen-docker&#39;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Test Cookbook</h3>

<p>Download <a href="https://github.com/opscode-cookbooks/ntp.git">ntp</a> cookbook for testing, beacuse it also serve as a testing documentation reference</p>

<h2>Execute Tests</h2>

<p>Change .kitchen.yml file of ntp cookbook to use kitchen docker plugin</p>

<figure class='code'><figcaption><span>example .kitchen.yml</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="nn">---</span>
</span><span class='line'><span class="l-Scalar-Plain">driver_plugin</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">docker</span>
</span><span class='line'><span class="l-Scalar-Plain">driver_config</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">require_chef_omnibus</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">platforms</span><span class="p-Indicator">:</span>
</span><span class='line'><span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">centos</span>
</span><span class='line'>  <span class="l-Scalar-Plain">driver_config</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="s">&quot;centos&quot;</span>
</span><span class='line'>    <span class="l-Scalar-Plain">platform</span><span class="p-Indicator">:</span> <span class="s">&quot;rhel&quot;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">run_list</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">recipe[yum]</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">suites</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">default</span>
</span><span class='line'>    <span class="l-Scalar-Plain">run_list</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">recipe[ntp::default]</span>
</span><span class='line'>    <span class="l-Scalar-Plain">attributes</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">ntp</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="l-Scalar-Plain">sync_clock</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
</span><span class='line'>        <span class="l-Scalar-Plain">sync_hw_clock</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">undo</span>
</span><span class='line'>    <span class="l-Scalar-Plain">run_list</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">recipe[ntp::undo]</span>
</span></code></pre></td></tr></table></div></figure>


<p>And run kitchen to execute tests in docker container</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">bundle</span> <span class="nb">exec</span> <span class="n">kitchen</span> <span class="nb">test</span>
</span></code></pre></td></tr></table></div></figure>


<h2>More optimisations</h2>

<p>Test Kitchen downloads chef omnibus package every time while spawning
a container, this step takes both time and bandwidth, this behaviour can
be override by setting require_chef_omnibus flag, there are also few tricks to speed up this step.</p>

<ul>
<li>use local repository for chef omnibus and override chef_omnibus_url flag</li>
<li>use lightweight gem like chef zero</li>
<li>utilize docker cache with  provision_command command</li>
<li>package omnibus with container and build image for testing</li>
</ul>


<p>New image can be easily created by using following
docker file</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>cat <span class="s">&lt;&lt; &#39;EOF&#39; &gt; Dockerfile</span>
</span><span class='line'><span class="s">FROM centos</span>
</span><span class='line'><span class="s">RUN curl -L https://www.opscode.com/chef/install.sh | sudo bash</span>
</span><span class='line'><span class="s">EOF</span>
</span><span class='line'>docker build -t  image_name .
</span></code></pre></td></tr></table></div></figure>


<p>Set and image: image_name in .kitchen.yml
file and execute tests more faster.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hoppr Platform in Last 10 Months]]></title>
    <link href="http://timusg.github.io/blog/2013/04/27/hoppr-platform-in-last-10-months/"/>
    <updated>2013-04-27T20:45:00+05:30</updated>
    <id>http://timusg.github.io/blog/2013/04/27/hoppr-platform-in-last-10-months</id>
    <content type="html"><![CDATA[<h2>Hoppr Platform Now</h2>

<p>with 7.6 m users hoppr platform is now handling around 600k checkins and 3m+ events per day.</p>

<p>underline is a heavily distributed architecture spread across three data centers and aws vpc.
it support zero downtime deployment and minimalistic service availability even in case of wan link failure.</p>

<h2>Tech Stack :</h2>

<ul>
<li>polyglot , 80% code base in ruby and 20 % in java , node and php</li>
<li>mongo</li>
<li>redis</li>
<li>mysql (percona)</li>
<li>elasticsearch</li>
<li>torquebox and hornetq</li>
<li>chef</li>
<li>nagious</li>
<li>apache and haproxy</li>
<li>centos</li>
<li>openvz</li>
</ul>


<!--more-->


<h2>A big rewrite</h2>

<p>it all start with a big rewrite of the the existing platform , which
was a big fat jsp code base, repeated for 6 telcos , code was not unit tested and
not even close to mvc 1.</p>

<p>initial version of new platform is developed in 2 months with a core domain
layer and application layer for vendor and access medium specific code.
the idea was to develop a core domain layer serve as api and other as application layer for device/vendor specific code, now we have around 20 similar micro services (some RESTish and some json over http),
each service is highly cohesive to device , vendor or a context.
apart from acting as anti corruption layers these micro services can also scale out independently.</p>

<h2>vertical to horizontal</h2>

<p>for first few months we tried to scale up with torquebox in big box with jvm optimized for huge pages, but
for zero downtime deployment and HA, we moved to scale out with openvz
containers with apache/ mod_cluster(http) and haproxy(jms) as load balancers.</p>

<p>we automated box setup to one click deployment using chef, and now we
have around 50 nodes handling all load.</p>

<h2>More About Architecture</h2>

<p>ussd checkin in our system requires response in less then
200ms , so system is modeled in events and base event checkin is
processed in less then 50ms, a checkin further emits another max 5 events for
various post processing actions , each event is processed by one or all sites.</p>

<p>site is cluster of backend services with own db and cache deployed in different datacenter,
and can independently process basic checkin and generally optimized for specific access
mediums.</p>

<p>sites are connected by a vpn tunnel over lease line.
site can play one or multiple role and we control it by giving it
capability and capability is controlled by chef.</p>

<p><strong>distributed architecture over wan is not a big deal ,but problems starts if it is not a shared nothing</strong> , and multiplies with type and intensity of sharing.</p>

<p>for some internal requirements we have to go with wan distribution and
hence to sync lots of data for mobile portability and
points/skipper/leaderboard calculations.</p>

<p><em>multi site replication</em></p>

<p>for muti site replication we are using application layer sync and
created a custom sync framework with fan out and repeat on failure with exponential backoff features,
data consistency is achieved by design by contract on sync endpoints.</p>

<p>sync framework&#8217;s core is built with hornetq and netty connectors and it is working really great even with remote listeners.</p>

<p><em>replicating single source of truth</em></p>

<p>points and leadernoard is single source of truth and it is calculated by one site,
we also need to access this data syncronpusly and it is not possible
over vpn because of encryption and multiple connections overhead.</p>

<p>we tried various approaches to sync this, and finally followed cqrs type approach and now have different
request paths for read and writes. points are calculated in one site and synced to remote redis slave and read operation is always from redis slave.</p>

<p>redis sync is almost realtime and very fast even for master to slave
of slave over 2 hop vpn links separated datacenters.</p>

<p><em>tuning centos</em></p>

<p>system defaults not always works and cpu and memory sometimes are not
indicators of bottleneck. we tuned various kernel
parameters for network and connection related stuff.</p>

<p>more on this in following post</p>

<h2>Lesson Learned</h2>

<ul>
<li>dont trust your api users , they can stress your system in no time,  use timeouts and circuit breakers</li>
<li>redis sync is very fast and it sync in millis from master to slave of
slave even over 2 vpn link separated datacenters</li>
<li>visualize every things , logstaligia is great for apache logs visualization and quick indicator of load</li>
<li>adopt configuration management as soon as possible</li>
</ul>

]]></content>
  </entry>
  
</feed>
