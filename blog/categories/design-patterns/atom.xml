<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: design patterns | Sumit Gupta's Blog]]></title>
  <link href="http://timusg.github.io/blog/categories/design-patterns/atom.xml" rel="self"/>
  <link href="http://timusg.github.io/"/>
  <updated>2013-12-09T23:15:11+05:30</updated>
  <id>http://timusg.github.io/</id>
  <author>
    <name><![CDATA[timusg]]></name>
    <email><![CDATA[timusga@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[code test and automate infrastructure]]></title>
    <link href="http://timusg.github.io/blog/2013/11/07/code-test-and-automate-infrastructure/"/>
    <updated>2013-11-07T16:36:00+05:30</updated>
    <id>http://timusg.github.io/blog/2013/11/07/code-test-and-automate-infrastructure</id>
    <content type="html"><![CDATA[<p><span class='pullquote-right' data-pullquote='Infrastructure as code mantra'></p>

<p>Managing infrastructure by hand or shell scripts is pain specially if your application architecture consists of multiple services.
For scaling such application adoption of Infrastructure as code mantra is a must have.
There are many ways and frameworks to japa this mantra and Chef, puppet ansible are few of many tools in configuration management segment which provides DSL to implement automated configuration , software installation , deployment etc ...</p>

<p>This area overlap between dev and ops domain and because of different skillset and practices of these domains, tools/patterns are still evolving to use the best of both domains,
slowly but it is picking up pace with recent increase in devops skills as more and more experts from both domains has started contributing in it.
</span></p>

<p>This post is about our adoption of this mantra with chef and applying current best practices for code, test and automate infrastructure.</p>

<!--more-->


<h2>Part One - The Code</h2>

<p>Code should be extensible, maintainable, reusable and in short modular
but keeping all chef code in single repository makes it bit difficult.</p>

<h3>Problems:</h3>

<ul>
<li>Cookbooks in one big repository are difficult to develop and test independently</li>
<li>Cookbooks in one repository are not modular and difficult to
distribute and reuse.</li>
<li>Code and data is in one place, but both changes with different pace.</li>
</ul>


<h3>Solution:</h3>

<p>To solve modularity issue, we use <a href="http://berkshelf.com/">berkshelf</a>.
It not only help in distributing and reusing cookbooks in a easy way, but also provides a foundation to apply good software principals, most of ideas in this post are from berkshelf itself.</p>

<p><em>We take care of following points while writing chef code.</em></p>

<ul>
<li>Use community cookbooks and if required write wrappers for extension.</li>
<li>No roles, use aggregated recipes
instead, roles provides global variables and also not versioned.</li>
<li>Use convention over configuration with using search and sane defaults.</li>
<li>Create application cookbook with independent git repo for every
application service.</li>
</ul>


<p>Following are the cookbook types and patterns, which I frequently encounter while writing chef code.</p>

<h2>Cookbook types and Patterns</h2>

<h3><a name="wrappercookbook"></a> Wrapper Recipe</h3>

<p>Wrapper recipe is like decorator pattern and is basic unit for extending <a href="#communitycookbook">community cookbooks</a>.</p>

<p>``` ruby  db.rb
include_recipe "postgresql::server"</p>

<p>foo "extra configuration for db" do
end
```</p>

<p>Wrapper recipe provides a way to encapsulate third party logic with your
logic in one recipe.</p>

<h3>Aggregated Recipe</h3>

<p>These are equivalent to aggregation pattern and only includes other recipes.</p>

<p><code>ruby  application cookbook: default.rb
include_recipe 'app'
include_recipe 'db'
</code></p>

<p>These are ideal candidate to replace roles,
For example default recipes can aggregate app and db recipes, and provide a role to quickly set up a dev test machine.</p>

<h3>Private Recipe</h3>

<p>Private recipe is like the abstract class and not exposed to public (outside of
 cookbook), can be used for code separation or reuse inside cookbook, it is convention to prefix its name with _ (underscore)</p>

<p>``` sh  private recipe example
.
-- recipes</p>

<pre><code>|-- _common.rb
|-- app.rb
`-- cache.rb
</code></pre>

<p>```</p>

<h3><a name="communitycookbook"></a> Community Cookbooks</h3>

<p>These are the open source cookbooks and maintained by community. These are Available in opscode or similar site for download.
Instead of reinventing the wheel prefer to use community cookbooks.</p>

<h3><a name="applictioncookbook"></a> Application Cookbook</h3>

<p>Application cookbook is the container of the configuration code for the application, I prefer to create one cookbook for
each rest service and different recipes in it for its various infrastructural layers for example recipes for each layer like db, app, cache, proxy, elb so on</p>

<p><code>`` sh  application cookbook dir structure
.
|-- Berksfile
|-- Vagrantfile
|-- attributes
|   |-- app.rb
|  </code>-- db.rb
|-- metadata.rb
`-- recipes</p>

<pre><code>|-- app.rb
|-- db.rb
`-- cache.rb
</code></pre>

<p>```
It provides a name space for application and its layers, for example application foo's
database is searchable with foo::db name so it replace role for
tag and search requirements.</p>

<p>Although multiple thin services based architecture often tempt to use one cookbook using some sort of tagging, but this approach often leads to conditional code in the end, So consider to use <a href="#librarycookbook"> library cookbook </a> for code reuse in application cookbooks.</p>

<h3><a name="librarycookbook"></a> Library Cookbook</h3>

<p>Library cookbook is like the brain and heart of application's configuration codebase, it is container of all the common code required in application cookbooks.
It is like abstarct class at cookbook level and thus contains no recipe and only provides abstraction over common code with lwrps and definitions.</p>

<p>Common code includes code for set up app servers (puma/nginx combo, torquebox), application rpm/omnibus installers and so on and depends on application stack.</p>

<p>It can be combined with the <a href="#basecookbook">base cookbook</a> which
provides recipes for basic node configuration.</p>

<h3><a name="basecookbook"></a> Base Cookbook</h3>

<p>It provides recipes for basic system configuration.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.
</span><span class='line'>|-- Berksfile
</span><span class='line'>|-- Vagrantfile
</span><span class='line'>|-- attributes
</span><span class='line'>|   |-- stagging.rb
</span><span class='line'>|   &lt;code>-- production.rb
</span><span class='line'>|-- metadata.rb
</span><span class='line'>&lt;/code>-- recipes&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>|-- _common.rb
</span><span class='line'>|-- stagging.rb
</span><span class='line'>`-- production.rb
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>I prefer to have separate recipes for different environments.</p>

<p>It replace the base role and install basic packages like Vim, tmux/screen, yum repos, environment specific tools like debug, tracing tools, monitoring agents etc. The benefit over role is that you can version it and also using different recipes for different environments provides more flexibility.</p>

<p>It can be combined with the <a href="#librarycookbook">Library cookbook</a>.</p>

<h3><a name="rolecookbook"></a> Role Cookbook</h3>

<p>This cookbook is replacement for the roles and can be used in place of base
cookbook if more fine grained control required for configuring roles.</p>

<p>But since we use application cookbook with roles like recipe names, this
cookbook is not really required.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.
</span><span class='line'>|-- Berksfile
</span><span class='line'>|-- Vagrantfile
</span><span class='line'>|-- attributes
</span><span class='line'>|   |-- web-server.rb
</span><span class='line'>|   &lt;code>-- db.rb
</span><span class='line'>|-- metadata.rb
</span><span class='line'>&lt;/code>-- recipes&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>|-- web-server.rb
</span><span class='line'>`-- db.rb
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>Infrastructure Essential Cookbook</h3>

<p>Any infrastructure contains two type of components</p>

<ul>
<li>Application and its dependencies like db, cache</li>
<li>Other essential components which crosscut entire infrastructure like chef server, etcd, bind, vpn, monitoring servers and CI server</li>
</ul>


<p>As Application cookbook take care of application related stuff, for configuring second I prefer to create another cookbook and I call it infra essential cookbook and it contains recipes and scripts for all remaining essential components, It also utilize wrapper recipe pattern with community cookbooks.</p>

<p>This cookbook provides two benefits</p>

<ol>
<li>one place for all scripts and recipes for all essential infrastructure
components.</li>
<li>A namespace, which is useful for searching and setting fqdn etc in
application cookbooks.</li>
</ol>


<p><em>Library, base and infrastructure cookbooks can be combined in one
cookbook like mixed
patterns or stay in their own cookbooks, but it all depends on codebase size
and testing needs</em></p>

<h2>Follow Up</h2>

<p>This post mainly covered the modularity and pattern aspects in chef
code base, follow-up posts of this series will cover code data separation, testing and auto deployment/provisioning strategies in chef managed infra.</p>
]]></content>
  </entry>
  
</feed>
