<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: devops | Sumit Gupta's Blog]]></title>
  <link href="http://timusg.github.io/blog/categories/devops/atom.xml" rel="self"/>
  <link href="http://timusg.github.io/"/>
  <updated>2013-12-09T23:22:06+05:30</updated>
  <id>http://timusg.github.io/</id>
  <author>
    <name><![CDATA[timusg]]></name>
    <email><![CDATA[timusga@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[code test and automate infrastructure - part II]]></title>
    <link href="http://timusg.github.io/blog/2013/12/09/code-test-and-automate-infrastructure-part-ii/"/>
    <updated>2013-12-09T18:54:00+05:30</updated>
    <id>http://timusg.github.io/blog/2013/12/09/code-test-and-automate-infrastructure-part-ii</id>
    <content type="html"><![CDATA[<h2>Part Two  - Testing</h2>

<p>Good code evolve with tests and CI is vital part of development cycle specially if multiple developers are working on the same code base,
these development practices also worth when applied to the infrastructure code.</p>

<p>One compelling reason for not doing so is that as compared to application code, infrastructure code is more resilient and not frequently changes. But still automated tests not only ensure sanity of code but often fasten development speed by reducing lot
of time required for manual testing of changes.</p>

<!--more-->


<h3>Codebase changes for testing</h3>

<p>As mentioned in <a href="/blog/2013/11/07/code-test-and-automate-infrastructure/">first part</a> one repo per cookbook for
modularity also simplify the independent testing of the cookbook,
but don't worry if you have legacy codebase, there are also tools like <a href="https://github.com/customink/strainer">strainer</a> which simplify testing of monolithic chef repo.</p>

<h3>Cookbook build pipeline</h3>

<p>Cookbook testing pipeline in CI can be like</p>

<p><center><img src='/images/plantuml/ac9c62cd2f97416ce48835bc9f070fdf.png'></center></p>

<h5>Lint</h5>

<p>rubocop is ruby static code analyzer and foodcritic is lint tool, they mainly target the code conventions,
foodcritic also check some coding error like invalid resource actions.</p>

<h5>Unit Tests:</h5>

<p>chef spec is unit testing framework which is based upon rspec of ruby land and is pseudo convergence
framework means it run cookbook locally without  without actually converging a node, the benefit it provide is fast feedback and good for testing template and configuration
files, permissions etc... , other tools like searchef and chef-zero
plays well with it.</p>

<h4>Integration Tests:</h4>

<p>Test kitchen is post convergence framework and it spawn a machine for running integration tests in isolated environment.
it support various test backend like bats and server spec, test kitchen tests are slower than unit tests test but it test actual system convergence and ensure that target system is configured properly, ideal for testing cookbooks in different distros.</p>

<p>test kitchen with vagrant based approach is slow and you can use
<a href="/blog/2013/10/15/testing-cookbook-with-docker-and-test-kitchen/">container based approach</a> for faster feedback.</p>

<h4>Cookbook for setting up CI server</h4>

<p>we have integrated docker in our CI server and are using test kitchen with docker plugin for running integration tests.
here is a <a href="https://github.com/codeignition/cookbook-pipeline">cookbook</a> which can set up Jenkins, Docker and required packages and create builds jobs from attributes.</p>

<h2>Follow Up</h2>

<p>Once automated test suits and CI server in place, then it open the
further doors for automating other knife related tasks for uploading
cookbook and bumping environments, the next article will cover
further automation in detail.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[code test and automate infrastructure]]></title>
    <link href="http://timusg.github.io/blog/2013/11/07/code-test-and-automate-infrastructure/"/>
    <updated>2013-11-07T16:36:00+05:30</updated>
    <id>http://timusg.github.io/blog/2013/11/07/code-test-and-automate-infrastructure</id>
    <content type="html"><![CDATA[<p><span class='pullquote-right' data-pullquote='Infrastructure as code mantra'></p>

<p>Managing infrastructure by hand or shell scripts is pain specially if your application architecture consists of multiple services.
For scaling such application adoption of Infrastructure as code mantra is a must have.
There are many ways and frameworks to japa this mantra and Chef, puppet ansible are few of many tools in configuration management segment which provides DSL to implement automated configuration , software installation , deployment etc ...</p>

<p>This area overlap between dev and ops domain and because of different skillset and practices of these domains, tools/patterns are still evolving to use the best of both domains,
slowly but it is picking up pace with recent increase in devops skills as more and more experts from both domains has started contributing in it.
</span></p>

<p>This post is about our adoption of this mantra with chef and applying current best practices for code, test and automate infrastructure.</p>

<!--more-->


<h2>Part One - The Code</h2>

<p>Code should be extensible, maintainable, reusable and in short modular
but keeping all chef code in single repository makes it bit difficult.</p>

<h3>Problems:</h3>

<ul>
<li>Cookbooks in one big repository are difficult to develop and test independently</li>
<li>Cookbooks in one repository are not modular and difficult to
distribute and reuse.</li>
<li>Code and data is in one place, but both changes with different pace.</li>
</ul>


<h3>Solution:</h3>

<p>To solve modularity issue, we use <a href="http://berkshelf.com/">berkshelf</a>.
It not only help in distributing and reusing cookbooks in a easy way, but also provides a foundation to apply good software principals, most of ideas in this post are from berkshelf itself.</p>

<p><em>We take care of following points while writing chef code.</em></p>

<ul>
<li>Use community cookbooks and if required write wrappers for extension.</li>
<li>No roles, use aggregated recipes
instead, roles provides global variables and also not versioned.</li>
<li>Use convention over configuration with using search and sane defaults.</li>
<li>Create application cookbook with independent git repo for every
application service.</li>
</ul>


<p>Following are the cookbook types and patterns, which I frequently encounter while writing chef code.</p>

<h2>Cookbook types and Patterns</h2>

<h3><a name="wrappercookbook"></a> Wrapper Recipe</h3>

<p>Wrapper recipe is like decorator pattern and is basic unit for extending <a href="#communitycookbook">community cookbooks</a>.</p>

<p>``` ruby  db.rb
include_recipe "postgresql::server"</p>

<p>foo "extra configuration for db" do
end
```</p>

<p>Wrapper recipe provides a way to encapsulate third party logic with your
logic in one recipe.</p>

<h3>Aggregated Recipe</h3>

<p>These are equivalent to aggregation pattern and only includes other recipes.</p>

<p><code>ruby  application cookbook: default.rb
include_recipe 'app'
include_recipe 'db'
</code></p>

<p>These are ideal candidate to replace roles,
For example default recipes can aggregate app and db recipes, and provide a role to quickly set up a dev test machine.</p>

<h3>Private Recipe</h3>

<p>Private recipe is like the abstract class and not exposed to public (outside of
 cookbook), can be used for code separation or reuse inside cookbook, it is convention to prefix its name with _ (underscore)</p>

<p>``` sh  private recipe example
.
-- recipes</p>

<pre><code>|-- _common.rb
|-- app.rb
`-- cache.rb
</code></pre>

<p>```</p>

<h3><a name="communitycookbook"></a> Community Cookbooks</h3>

<p>These are the open source cookbooks and maintained by community. These are Available in opscode or similar site for download.
Instead of reinventing the wheel prefer to use community cookbooks.</p>

<h3><a name="applictioncookbook"></a> Application Cookbook</h3>

<p>Application cookbook is the container of the configuration code for the application, I prefer to create one cookbook for
each rest service and different recipes in it for its various infrastructural layers for example recipes for each layer like db, app, cache, proxy, elb so on</p>

<p><code>`` sh  application cookbook dir structure
.
|-- Berksfile
|-- Vagrantfile
|-- attributes
|   |-- app.rb
|  </code>-- db.rb
|-- metadata.rb
`-- recipes</p>

<pre><code>|-- app.rb
|-- db.rb
`-- cache.rb
</code></pre>

<p>```
It provides a name space for application and its layers, for example application foo's
database is searchable with foo::db name so it replace role for
tag and search requirements.</p>

<p>Although multiple thin services based architecture often tempt to use one cookbook using some sort of tagging, but this approach often leads to conditional code in the end, So consider to use <a href="#librarycookbook"> library cookbook </a> for code reuse in application cookbooks.</p>

<h3><a name="librarycookbook"></a> Library Cookbook</h3>

<p>Library cookbook is like the brain and heart of application's configuration codebase, it is container of all the common code required in application cookbooks.
It is like abstarct class at cookbook level and thus contains no recipe and only provides abstraction over common code with lwrps and definitions.</p>

<p>Common code includes code for set up app servers (puma/nginx combo, torquebox), application rpm/omnibus installers and so on and depends on application stack.</p>

<p>It can be combined with the <a href="#basecookbook">base cookbook</a> which
provides recipes for basic node configuration.</p>

<h3><a name="basecookbook"></a> Base Cookbook</h3>

<p>It provides recipes for basic system configuration.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.
</span><span class='line'>|-- Berksfile
</span><span class='line'>|-- Vagrantfile
</span><span class='line'>|-- attributes
</span><span class='line'>|   |-- stagging.rb
</span><span class='line'>|   &lt;code>-- production.rb
</span><span class='line'>|-- metadata.rb
</span><span class='line'>&lt;/code>-- recipes&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>|-- _common.rb
</span><span class='line'>|-- stagging.rb
</span><span class='line'>`-- production.rb
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>I prefer to have separate recipes for different environments.</p>

<p>It replace the base role and install basic packages like Vim, tmux/screen, yum repos, environment specific tools like debug, tracing tools, monitoring agents etc. The benefit over role is that you can version it and also using different recipes for different environments provides more flexibility.</p>

<p>It can be combined with the <a href="#librarycookbook">Library cookbook</a>.</p>

<h3><a name="rolecookbook"></a> Role Cookbook</h3>

<p>This cookbook is replacement for the roles and can be used in place of base
cookbook if more fine grained control required for configuring roles.</p>

<p>But since we use application cookbook with roles like recipe names, this
cookbook is not really required.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.
</span><span class='line'>|-- Berksfile
</span><span class='line'>|-- Vagrantfile
</span><span class='line'>|-- attributes
</span><span class='line'>|   |-- web-server.rb
</span><span class='line'>|   &lt;code>-- db.rb
</span><span class='line'>|-- metadata.rb
</span><span class='line'>&lt;/code>-- recipes&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>|-- web-server.rb
</span><span class='line'>`-- db.rb
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>Infrastructure Essential Cookbook</h3>

<p>Any infrastructure contains two type of components</p>

<ul>
<li>Application and its dependencies like db, cache</li>
<li>Other essential components which crosscut entire infrastructure like chef server, etcd, bind, vpn, monitoring servers and CI server</li>
</ul>


<p>As Application cookbook take care of application related stuff, for configuring second I prefer to create another cookbook and I call it infra essential cookbook and it contains recipes and scripts for all remaining essential components, It also utilize wrapper recipe pattern with community cookbooks.</p>

<p>This cookbook provides two benefits</p>

<ol>
<li>one place for all scripts and recipes for all essential infrastructure
components.</li>
<li>A namespace, which is useful for searching and setting fqdn etc in
application cookbooks.</li>
</ol>


<p><em>Library, base and infrastructure cookbooks can be combined in one
cookbook like mixed
patterns or stay in their own cookbooks, but it all depends on codebase size
and testing needs</em></p>

<h2>Follow Up</h2>

<p>This post mainly covered the modularity and pattern aspects in chef
code base, follow-up posts of this series will cover code data separation, testing and auto deployment/provisioning strategies in chef managed infra.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing chef cookbook with docker and test kitchen]]></title>
    <link href="http://timusg.github.io/blog/2013/10/15/testing-cookbook-with-docker-and-test-kitchen/"/>
    <updated>2013-10-15T17:44:00+05:30</updated>
    <id>http://timusg.github.io/blog/2013/10/15/testing-cookbook-with-docker-and-test-kitchen</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/opscode/test-kitchen">Test Kitchen</a> is a framework for isolated integration testing of chef
recipes</p>

<p>For testing a recipe it spawn a vm, execute tests and then destroys it.
For local cookbook development and manual testing of changes
<a href="http://www.vagrantup.com/">vagarnt</a> is definitely the best choice,
but for developing cookbook with automated tests suits faster test feedback is really important, since VM based approach is very
slow and it is worth to try containers for cookbook testing.</p>

<!--more-->


<h2>Optimisation with containers</h2>

<p>Containers like openvz and lxc are faster to launch and are very lightweight as compared to virtual box and other VM based backends.</p>

<p>As compared to openvz, lxc is available on the mainstream linux kernel but managing lxc container with scripts
is not an easy task, there are two lxc baced framework available, <a href="https://github.com/fgrehm/vagrant-lxc">vagrant lxc</a>(vagrant lxc provider) and <a href="https://www.docker.io/">docker</a> (package and run application as container) which provides
good abstraction layer over lxc.</p>

<p>Test kitchen has a architecture for pluggable virtualization backend and it support vagrant, ec2 and recently
with <a href="https://github.com/portertech/kitchen-docker">kitchen-docker</a> plugin, docker can also used as driver.</p>

<p>I am using following setup to use test kitchen with docker.</p>

<h2>Setup</h2>

<h3>Install docker</h3>

<p><a href="https://www.docker.io/gettingstarted/">Install</a> it for supported
platform or
Install it with community cookbook with chef and berkself</p>

<p><code>ruby Berksfile to install docker
site :opscode
metadata
group :integration do
cookbook 'docker'
end
</code></p>

<h3>Install test-kitchen and docker driver</h3>

<p>Can be installed with bundler by using following Gemfile file</p>

<p>``` ruby Gemfile
source 'https://rubygems.org'</p>

<p>gem 'berkshelf', '~> 2.0'</p>

<p>group :integration do
  gem 'test-kitchen', '~> 1.0.0.beta'
  gem 'kitchen-docker'
end
```</p>

<h3>Sample Cookbook</h3>

<p>Download <a href="https://github.com/opscode-cookbooks/ntp.git">ntp</a> cookbook for testing, beacuse it also serve as a testing documentation reference</p>

<h2>Execute Tests</h2>

<p>Change .kitchen.yml file of ntp cookbook to use kitchen docker plugin</p>

<h2>``` yml example .kitchen.yml</h2>

<p>driver_plugin: docker
driver_config:
  require_chef_omnibus: true</p>

<p>platforms:
- name: centos
  driver_config:</p>

<pre><code>image: "centos"
platform: "rhel"
</code></pre>

<p>  run_list:
  - recipe[yum]</p>

<p>suites:
  - name: default</p>

<pre><code>run_list:
  - recipe[ntp::default]
attributes:
  ntp:
    sync_clock: true
    sync_hw_clock: true
</code></pre>

<ul>
<li>name: undo
run_list:

<ul>
<li>recipe[ntp::undo]
```</li>
</ul>
</li>
</ul>


<p>And run kitchen to execute tests in docker container</p>

<p><code>ruby
bundle exec kitchen test
</code></p>

<h2>More optimisations</h2>

<p>Test Kitchen downloads chef omnibus package every time while spawning
a container, this step takes both time and bandwidth, this can be turned
off by setting require_chef_omnibus flag to false, following are other options to optimize this</p>

<ul>
<li>use local repository for chef omnibus and override chef_omnibus_url flag</li>
<li>use lightweight gem like chef zero</li>
<li>utilize docker cache with  provision_command command</li>
<li>build new image with installed chef for testing</li>
</ul>


<p>New image can be easily created by using following
commands</p>

<p>``` sh
cat &lt;&lt; 'EOF' > Dockerfile
FROM centos
RUN curl -L https://www.opscode.com/chef/install.sh | sudo bash</p>

<p>RUN #install additopnal packages</p>

<p>EOF
docker build -t  image_name .
```</p>

<p>Set image key to image_name in .kitchen.yml
file and execute tests more faster.</p>
]]></content>
  </entry>
  
</feed>
